// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: teams.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addTeamMember = `-- name: AddTeamMember :exec
INSERT INTO team_members (team_id, user_id, role, created_at)
VALUES ($1, $2, $3, $4)
ON CONFLICT (team_id, user_id) DO NOTHING
`

type AddTeamMemberParams struct {
	TeamID    string             `json:"team_id"`
	UserID    string             `json:"user_id"`
	Role      string             `json:"role"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) AddTeamMember(ctx context.Context, arg AddTeamMemberParams) error {
	_, err := q.db.Exec(ctx, addTeamMember,
		arg.TeamID,
		arg.UserID,
		arg.Role,
		arg.CreatedAt,
	)
	return err
}

const createTeam = `-- name: CreateTeam :exec
INSERT INTO teams (id, name, created_at)
VALUES ($1, $2, $3)
`

type CreateTeamParams struct {
	ID        string             `json:"id"`
	Name      string             `json:"name"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) CreateTeam(ctx context.Context, arg CreateTeamParams) error {
	_, err := q.db.Exec(ctx, createTeam, arg.ID, arg.Name, arg.CreatedAt)
	return err
}

const deleteTeam = `-- name: DeleteTeam :exec
DELETE FROM teams
WHERE id = $1
`

func (q *Queries) DeleteTeam(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteTeam, id)
	return err
}

const deleteTeamMember = `-- name: DeleteTeamMember :exec
DELETE FROM team_members
WHERE team_id = $1
  AND user_id = $2
`

type DeleteTeamMemberParams struct {
	TeamID string `json:"team_id"`
	UserID string `json:"user_id"`
}

func (q *Queries) DeleteTeamMember(ctx context.Context, arg DeleteTeamMemberParams) error {
	_, err := q.db.Exec(ctx, deleteTeamMember, arg.TeamID, arg.UserID)
	return err
}

const getOldestOtherTeamMember = `-- name: GetOldestOtherTeamMember :one
SELECT user_id
FROM team_members
WHERE team_id = $1
  AND user_id <> $2
ORDER BY created_at ASC
LIMIT 1
`

type GetOldestOtherTeamMemberParams struct {
	TeamID string `json:"team_id"`
	UserID string `json:"user_id"`
}

func (q *Queries) GetOldestOtherTeamMember(ctx context.Context, arg GetOldestOtherTeamMemberParams) (string, error) {
	row := q.db.QueryRow(ctx, getOldestOtherTeamMember, arg.TeamID, arg.UserID)
	var user_id string
	err := row.Scan(&user_id)
	return user_id, err
}

const getTeamStateRevision = `-- name: GetTeamStateRevision :one
SELECT state_revision
FROM teams
WHERE id = $1
`

func (q *Queries) GetTeamStateRevision(ctx context.Context, id string) (int64, error) {
	row := q.db.QueryRow(ctx, getTeamStateRevision, id)
	var state_revision int64
	err := row.Scan(&state_revision)
	return state_revision, err
}

const listMembershipsByUserID = `-- name: ListMembershipsByUserID :many
SELECT tm.team_id, tm.role, t.name AS team_name
FROM team_members tm
INNER JOIN teams t ON t.id = tm.team_id
WHERE tm.user_id = $1
`

type ListMembershipsByUserIDRow struct {
	TeamID   string `json:"team_id"`
	Role     string `json:"role"`
	TeamName string `json:"team_name"`
}

func (q *Queries) ListMembershipsByUserID(ctx context.Context, userID string) ([]ListMembershipsByUserIDRow, error) {
	rows, err := q.db.Query(ctx, listMembershipsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMembershipsByUserIDRow
	for rows.Next() {
		var i ListMembershipsByUserIDRow
		if err := rows.Scan(&i.TeamID, &i.Role, &i.TeamName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamIDsForClose = `-- name: ListTeamIDsForClose :many
SELECT t.id
FROM teams t
WHERE EXISTS (
  SELECT 1
  FROM team_members tm
  WHERE tm.team_id = t.id
)
ORDER BY t.created_at ASC, t.id ASC
`

func (q *Queries) ListTeamIDsForClose(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, listTeamIDsForClose)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamMembersByTeamID = `-- name: ListTeamMembersByTeamID :many
SELECT
  tm.team_id,
  tm.user_id,
  tm.role,
  tm.created_at,
  u.display_name,
  COALESCE(u.nickname, '') AS nickname
FROM team_members tm
INNER JOIN users u ON u.id = tm.user_id
WHERE tm.team_id = $1
ORDER BY tm.created_at ASC
`

type ListTeamMembersByTeamIDRow struct {
	TeamID      string             `json:"team_id"`
	UserID      string             `json:"user_id"`
	Role        string             `json:"role"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	DisplayName string             `json:"display_name"`
	Nickname    string             `json:"nickname"`
}

func (q *Queries) ListTeamMembersByTeamID(ctx context.Context, teamID string) ([]ListTeamMembersByTeamIDRow, error) {
	rows, err := q.db.Query(ctx, listTeamMembersByTeamID, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTeamMembersByTeamIDRow
	for rows.Next() {
		var i ListTeamMembersByTeamIDRow
		if err := rows.Scan(
			&i.TeamID,
			&i.UserID,
			&i.Role,
			&i.CreatedAt,
			&i.DisplayName,
			&i.Nickname,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTeamMemberRole = `-- name: UpdateTeamMemberRole :exec
UPDATE team_members
SET role = $3
WHERE team_id = $1
  AND user_id = $2
`

type UpdateTeamMemberRoleParams struct {
	TeamID string `json:"team_id"`
	UserID string `json:"user_id"`
	Role   string `json:"role"`
}

func (q *Queries) UpdateTeamMemberRole(ctx context.Context, arg UpdateTeamMemberRoleParams) error {
	_, err := q.db.Exec(ctx, updateTeamMemberRole, arg.TeamID, arg.UserID, arg.Role)
	return err
}

const updateTeamName = `-- name: UpdateTeamName :exec
UPDATE teams
SET name = $2
WHERE id = $1
`

type UpdateTeamNameParams struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) UpdateTeamName(ctx context.Context, arg UpdateTeamNameParams) error {
	_, err := q.db.Exec(ctx, updateTeamName, arg.ID, arg.Name)
	return err
}

const updateTeamStateRevisionIfMatch = `-- name: UpdateTeamStateRevisionIfMatch :one
UPDATE teams
SET state_revision = state_revision + 1
WHERE id = $1
  AND state_revision = $2
RETURNING state_revision
`

type UpdateTeamStateRevisionIfMatchParams struct {
	ID            string `json:"id"`
	StateRevision int64  `json:"state_revision"`
}

func (q *Queries) UpdateTeamStateRevisionIfMatch(ctx context.Context, arg UpdateTeamStateRevisionIfMatchParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateTeamStateRevisionIfMatch, arg.ID, arg.StateRevision)
	var state_revision int64
	err := row.Scan(&state_revision)
	return state_revision, err
}
