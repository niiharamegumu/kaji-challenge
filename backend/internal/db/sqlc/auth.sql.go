// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: auth.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const consumeExchangeCode = `-- name: ConsumeExchangeCode :exec
UPDATE oauth_exchange_codes
SET used_at = NOW()
WHERE code = $1 AND used_at IS NULL
`

func (q *Queries) ConsumeExchangeCode(ctx context.Context, code string) error {
	_, err := q.db.Exec(ctx, consumeExchangeCode, code)
	return err
}

const createSession = `-- name: CreateSession :exec
INSERT INTO sessions (token, user_id, created_at, expires_at)
VALUES ($1, $2, NOW(), NULL)
`

type CreateSessionParams struct {
	Token  string `json:"token"`
	UserID string `json:"user_id"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) error {
	_, err := q.db.Exec(ctx, createSession, arg.Token, arg.UserID)
	return err
}

const deleteAuthRequest = `-- name: DeleteAuthRequest :exec
DELETE FROM oauth_auth_requests
WHERE state = $1
`

func (q *Queries) DeleteAuthRequest(ctx context.Context, state string) error {
	_, err := q.db.Exec(ctx, deleteAuthRequest, state)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions
WHERE token = $1
`

func (q *Queries) DeleteSession(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, deleteSession, token)
	return err
}

const getAuthRequest = `-- name: GetAuthRequest :one
SELECT state, nonce, code_verifier, expires_at, created_at
FROM oauth_auth_requests
WHERE state = $1
`

func (q *Queries) GetAuthRequest(ctx context.Context, state string) (OauthAuthRequest, error) {
	row := q.db.QueryRow(ctx, getAuthRequest, state)
	var i OauthAuthRequest
	err := row.Scan(
		&i.State,
		&i.Nonce,
		&i.CodeVerifier,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getExchangeCode = `-- name: GetExchangeCode :one
SELECT code, user_id, expires_at, used_at, created_at
FROM oauth_exchange_codes
WHERE code = $1
`

func (q *Queries) GetExchangeCode(ctx context.Context, code string) (OauthExchangeCode, error) {
	row := q.db.QueryRow(ctx, getExchangeCode, code)
	var i OauthExchangeCode
	err := row.Scan(
		&i.Code,
		&i.UserID,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getSessionByToken = `-- name: GetSessionByToken :one
SELECT s.token, s.user_id, s.created_at, s.expires_at
FROM sessions AS s
INNER JOIN users AS u ON u.id = s.user_id
WHERE s.token = $1
  AND (s.expires_at IS NULL OR s.expires_at > NOW())
`

func (q *Queries) GetSessionByToken(ctx context.Context, token string) (Session, error) {
	row := q.db.QueryRow(ctx, getSessionByToken, token)
	var i Session
	err := row.Scan(
		&i.Token,
		&i.UserID,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const insertAuthRequest = `-- name: InsertAuthRequest :exec
INSERT INTO oauth_auth_requests (state, nonce, code_verifier, expires_at, created_at)
VALUES ($1, $2, $3, $4, NOW())
ON CONFLICT (state) DO UPDATE SET
  nonce = EXCLUDED.nonce,
  code_verifier = EXCLUDED.code_verifier,
  expires_at = EXCLUDED.expires_at
`

type InsertAuthRequestParams struct {
	State        string             `json:"state"`
	Nonce        string             `json:"nonce"`
	CodeVerifier string             `json:"code_verifier"`
	ExpiresAt    pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) InsertAuthRequest(ctx context.Context, arg InsertAuthRequestParams) error {
	_, err := q.db.Exec(ctx, insertAuthRequest,
		arg.State,
		arg.Nonce,
		arg.CodeVerifier,
		arg.ExpiresAt,
	)
	return err
}

const insertExchangeCode = `-- name: InsertExchangeCode :exec
INSERT INTO oauth_exchange_codes (code, user_id, expires_at, used_at, created_at)
VALUES ($1, $2, $3, NULL, NOW())
ON CONFLICT (code) DO UPDATE SET
  user_id = EXCLUDED.user_id,
  expires_at = EXCLUDED.expires_at,
  used_at = NULL
`

type InsertExchangeCodeParams struct {
	Code      string             `json:"code"`
	UserID    string             `json:"user_id"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) InsertExchangeCode(ctx context.Context, arg InsertExchangeCodeParams) error {
	_, err := q.db.Exec(ctx, insertExchangeCode, arg.Code, arg.UserID, arg.ExpiresAt)
	return err
}
