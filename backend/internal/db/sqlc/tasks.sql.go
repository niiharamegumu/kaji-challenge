// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: tasks.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const clearTaskAssigneeByTeamAndUser = `-- name: ClearTaskAssigneeByTeamAndUser :exec
UPDATE tasks
SET assignee_user_id = NULL
WHERE team_id = $1
  AND assignee_user_id = NULLIF($2, '')::uuid
  AND deleted_at IS NULL
`

type ClearTaskAssigneeByTeamAndUserParams struct {
	TeamID  string      `json:"team_id"`
	Column2 interface{} `json:"column_2"`
}

func (q *Queries) ClearTaskAssigneeByTeamAndUser(ctx context.Context, arg ClearTaskAssigneeByTeamAndUserParams) error {
	_, err := q.db.Exec(ctx, clearTaskAssigneeByTeamAndUser, arg.TeamID, arg.Column2)
	return err
}

const createTask = `-- name: CreateTask :exec
INSERT INTO tasks (id, team_id, title, notes, type, penalty_points, assignee_user_id, required_completions_per_week, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, NULLIF($7, '')::uuid, $8, $9, $10)
`

type CreateTaskParams struct {
	ID                         string             `json:"id"`
	TeamID                     string             `json:"team_id"`
	Title                      string             `json:"title"`
	Notes                      pgtype.Text        `json:"notes"`
	Type                       string             `json:"type"`
	PenaltyPoints              int32              `json:"penalty_points"`
	Column7                    interface{}        `json:"column_7"`
	RequiredCompletionsPerWeek int32              `json:"required_completions_per_week"`
	CreatedAt                  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                  pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) error {
	_, err := q.db.Exec(ctx, createTask,
		arg.ID,
		arg.TeamID,
		arg.Title,
		arg.Notes,
		arg.Type,
		arg.PenaltyPoints,
		arg.Column7,
		arg.RequiredCompletionsPerWeek,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const deleteTask = `-- name: DeleteTask :exec
UPDATE tasks
SET deleted_at = NOW(),
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteTask(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteTask, id)
	return err
}

const getEarliestTaskCreatedAtByTeam = `-- name: GetEarliestTaskCreatedAtByTeam :one
SELECT MIN(created_at)::timestamptz AS created_at
FROM tasks
WHERE team_id = $1
`

func (q *Queries) GetEarliestTaskCreatedAtByTeam(ctx context.Context, teamID string) (pgtype.Timestamptz, error) {
	row := q.db.QueryRow(ctx, getEarliestTaskCreatedAtByTeam, teamID)
	var created_at pgtype.Timestamptz
	err := row.Scan(&created_at)
	return created_at, err
}

const getTaskByID = `-- name: GetTaskByID :one
SELECT id, team_id, title, notes, type, penalty_points, COALESCE(assignee_user_id::text, '') AS assignee_user_id, required_completions_per_week, created_at, updated_at, deleted_at
FROM tasks
WHERE id = $1
`

type GetTaskByIDRow struct {
	ID                         string             `json:"id"`
	TeamID                     string             `json:"team_id"`
	Title                      string             `json:"title"`
	Notes                      pgtype.Text        `json:"notes"`
	Type                       string             `json:"type"`
	PenaltyPoints              int32              `json:"penalty_points"`
	AssigneeUserID             interface{}        `json:"assignee_user_id"`
	RequiredCompletionsPerWeek int32              `json:"required_completions_per_week"`
	CreatedAt                  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                  pgtype.Timestamptz `json:"updated_at"`
	DeletedAt                  pgtype.Timestamptz `json:"deleted_at"`
}

func (q *Queries) GetTaskByID(ctx context.Context, id string) (GetTaskByIDRow, error) {
	row := q.db.QueryRow(ctx, getTaskByID, id)
	var i GetTaskByIDRow
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.Title,
		&i.Notes,
		&i.Type,
		&i.PenaltyPoints,
		&i.AssigneeUserID,
		&i.RequiredCompletionsPerWeek,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listTasksByTeamID = `-- name: ListTasksByTeamID :many
SELECT id, team_id, title, notes, type, penalty_points, COALESCE(assignee_user_id::text, '') AS assignee_user_id, required_completions_per_week, created_at, updated_at, deleted_at
FROM tasks
WHERE team_id = $1
  AND deleted_at IS NULL
ORDER BY created_at
`

type ListTasksByTeamIDRow struct {
	ID                         string             `json:"id"`
	TeamID                     string             `json:"team_id"`
	Title                      string             `json:"title"`
	Notes                      pgtype.Text        `json:"notes"`
	Type                       string             `json:"type"`
	PenaltyPoints              int32              `json:"penalty_points"`
	AssigneeUserID             interface{}        `json:"assignee_user_id"`
	RequiredCompletionsPerWeek int32              `json:"required_completions_per_week"`
	CreatedAt                  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                  pgtype.Timestamptz `json:"updated_at"`
	DeletedAt                  pgtype.Timestamptz `json:"deleted_at"`
}

func (q *Queries) ListTasksByTeamID(ctx context.Context, teamID string) ([]ListTasksByTeamIDRow, error) {
	rows, err := q.db.Query(ctx, listTasksByTeamID, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTasksByTeamIDRow
	for rows.Next() {
		var i ListTasksByTeamIDRow
		if err := rows.Scan(
			&i.ID,
			&i.TeamID,
			&i.Title,
			&i.Notes,
			&i.Type,
			&i.PenaltyPoints,
			&i.AssigneeUserID,
			&i.RequiredCompletionsPerWeek,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksEffectiveForCloseByTeamAndType = `-- name: ListTasksEffectiveForCloseByTeamAndType :many
SELECT id, team_id, title, notes, type, penalty_points, COALESCE(assignee_user_id::text, '') AS assignee_user_id, required_completions_per_week, created_at, updated_at, deleted_at
FROM tasks
WHERE team_id = $1
  AND type = $2
  AND created_at < $3
  AND (deleted_at IS NULL OR deleted_at >= $3)
ORDER BY created_at
`

type ListTasksEffectiveForCloseByTeamAndTypeParams struct {
	TeamID    string             `json:"team_id"`
	Type      string             `json:"type"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type ListTasksEffectiveForCloseByTeamAndTypeRow struct {
	ID                         string             `json:"id"`
	TeamID                     string             `json:"team_id"`
	Title                      string             `json:"title"`
	Notes                      pgtype.Text        `json:"notes"`
	Type                       string             `json:"type"`
	PenaltyPoints              int32              `json:"penalty_points"`
	AssigneeUserID             interface{}        `json:"assignee_user_id"`
	RequiredCompletionsPerWeek int32              `json:"required_completions_per_week"`
	CreatedAt                  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                  pgtype.Timestamptz `json:"updated_at"`
	DeletedAt                  pgtype.Timestamptz `json:"deleted_at"`
}

func (q *Queries) ListTasksEffectiveForCloseByTeamAndType(ctx context.Context, arg ListTasksEffectiveForCloseByTeamAndTypeParams) ([]ListTasksEffectiveForCloseByTeamAndTypeRow, error) {
	rows, err := q.db.Query(ctx, listTasksEffectiveForCloseByTeamAndType, arg.TeamID, arg.Type, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTasksEffectiveForCloseByTeamAndTypeRow
	for rows.Next() {
		var i ListTasksEffectiveForCloseByTeamAndTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.TeamID,
			&i.Title,
			&i.Notes,
			&i.Type,
			&i.PenaltyPoints,
			&i.AssigneeUserID,
			&i.RequiredCompletionsPerWeek,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksForMonthlyStatusByTeam = `-- name: ListTasksForMonthlyStatusByTeam :many
SELECT id, title, type, penalty_points, created_at, deleted_at
FROM tasks
WHERE team_id = $1
  AND created_at < $3
  AND deleted_at IS NULL
UNION ALL
SELECT id, title, type, penalty_points, created_at, deleted_at
FROM tasks
WHERE team_id = $1
  AND created_at < $3
  AND deleted_at >= $2
ORDER BY created_at, id
`

type ListTasksForMonthlyStatusByTeamParams struct {
	TeamID    string             `json:"team_id"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type ListTasksForMonthlyStatusByTeamRow struct {
	ID            string             `json:"id"`
	Title         string             `json:"title"`
	Type          string             `json:"type"`
	PenaltyPoints int32              `json:"penalty_points"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	DeletedAt     pgtype.Timestamptz `json:"deleted_at"`
}

func (q *Queries) ListTasksForMonthlyStatusByTeam(ctx context.Context, arg ListTasksForMonthlyStatusByTeamParams) ([]ListTasksForMonthlyStatusByTeamRow, error) {
	rows, err := q.db.Query(ctx, listTasksForMonthlyStatusByTeam, arg.TeamID, arg.DeletedAt, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTasksForMonthlyStatusByTeamRow
	for rows.Next() {
		var i ListTasksForMonthlyStatusByTeamRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Type,
			&i.PenaltyPoints,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUndeletedTasksByTeamID = `-- name: ListUndeletedTasksByTeamID :many
SELECT id, team_id, title, notes, type, penalty_points, COALESCE(assignee_user_id::text, '') AS assignee_user_id, required_completions_per_week, created_at, updated_at, deleted_at
FROM tasks
WHERE team_id = $1
  AND deleted_at IS NULL
ORDER BY created_at
`

type ListUndeletedTasksByTeamIDRow struct {
	ID                         string             `json:"id"`
	TeamID                     string             `json:"team_id"`
	Title                      string             `json:"title"`
	Notes                      pgtype.Text        `json:"notes"`
	Type                       string             `json:"type"`
	PenaltyPoints              int32              `json:"penalty_points"`
	AssigneeUserID             interface{}        `json:"assignee_user_id"`
	RequiredCompletionsPerWeek int32              `json:"required_completions_per_week"`
	CreatedAt                  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                  pgtype.Timestamptz `json:"updated_at"`
	DeletedAt                  pgtype.Timestamptz `json:"deleted_at"`
}

func (q *Queries) ListUndeletedTasksByTeamID(ctx context.Context, teamID string) ([]ListUndeletedTasksByTeamIDRow, error) {
	rows, err := q.db.Query(ctx, listUndeletedTasksByTeamID, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUndeletedTasksByTeamIDRow
	for rows.Next() {
		var i ListUndeletedTasksByTeamIDRow
		if err := rows.Scan(
			&i.ID,
			&i.TeamID,
			&i.Title,
			&i.Notes,
			&i.Type,
			&i.PenaltyPoints,
			&i.AssigneeUserID,
			&i.RequiredCompletionsPerWeek,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTask = `-- name: UpdateTask :exec
UPDATE tasks
SET title = $2,
    notes = $3,
    penalty_points = $4,
    assignee_user_id = NULLIF($5, '')::uuid,
    required_completions_per_week = $6,
    updated_at = $7
WHERE id = $1
`

type UpdateTaskParams struct {
	ID                         string             `json:"id"`
	Title                      string             `json:"title"`
	Notes                      pgtype.Text        `json:"notes"`
	PenaltyPoints              int32              `json:"penalty_points"`
	Column5                    interface{}        `json:"column_5"`
	RequiredCompletionsPerWeek int32              `json:"required_completions_per_week"`
	UpdatedAt                  pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateTask(ctx context.Context, arg UpdateTaskParams) error {
	_, err := q.db.Exec(ctx, updateTask,
		arg.ID,
		arg.Title,
		arg.Notes,
		arg.PenaltyPoints,
		arg.Column5,
		arg.RequiredCompletionsPerWeek,
		arg.UpdatedAt,
	)
	return err
}
