// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: task_completions.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countTaskCompletionsInRange = `-- name: CountTaskCompletionsInRange :one
SELECT COUNT(*)::bigint
FROM task_completions
WHERE task_id = $1
  AND target_date >= $2
  AND target_date <= $3
`

type CountTaskCompletionsInRangeParams struct {
	TaskID       string      `json:"task_id"`
	TargetDate   pgtype.Date `json:"target_date"`
	TargetDate_2 pgtype.Date `json:"target_date_2"`
}

func (q *Queries) CountTaskCompletionsInRange(ctx context.Context, arg CountTaskCompletionsInRangeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countTaskCompletionsInRange, arg.TaskID, arg.TargetDate, arg.TargetDate_2)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const createTaskCompletion = `-- name: CreateTaskCompletion :exec
INSERT INTO task_completions (task_id, target_date, created_at)
VALUES ($1, $2, NOW())
ON CONFLICT (task_id, target_date) DO NOTHING
`

type CreateTaskCompletionParams struct {
	TaskID     string      `json:"task_id"`
	TargetDate pgtype.Date `json:"target_date"`
}

func (q *Queries) CreateTaskCompletion(ctx context.Context, arg CreateTaskCompletionParams) error {
	_, err := q.db.Exec(ctx, createTaskCompletion, arg.TaskID, arg.TargetDate)
	return err
}

const deleteTaskCompletion = `-- name: DeleteTaskCompletion :exec
DELETE FROM task_completions
WHERE task_id = $1 AND target_date = $2
`

type DeleteTaskCompletionParams struct {
	TaskID     string      `json:"task_id"`
	TargetDate pgtype.Date `json:"target_date"`
}

func (q *Queries) DeleteTaskCompletion(ctx context.Context, arg DeleteTaskCompletionParams) error {
	_, err := q.db.Exec(ctx, deleteTaskCompletion, arg.TaskID, arg.TargetDate)
	return err
}

const deleteTaskCompletionsByTaskID = `-- name: DeleteTaskCompletionsByTaskID :exec
DELETE FROM task_completions
WHERE task_id = $1
`

func (q *Queries) DeleteTaskCompletionsByTaskID(ctx context.Context, taskID string) error {
	_, err := q.db.Exec(ctx, deleteTaskCompletionsByTaskID, taskID)
	return err
}

const hasTaskCompletion = `-- name: HasTaskCompletion :one
SELECT EXISTS (
  SELECT 1
  FROM task_completions
  WHERE task_id = $1 AND target_date = $2
)
`

type HasTaskCompletionParams struct {
	TaskID     string      `json:"task_id"`
	TargetDate pgtype.Date `json:"target_date"`
}

func (q *Queries) HasTaskCompletion(ctx context.Context, arg HasTaskCompletionParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasTaskCompletion, arg.TaskID, arg.TargetDate)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
