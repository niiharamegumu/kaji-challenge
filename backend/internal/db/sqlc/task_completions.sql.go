// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: task_completions.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTaskCompletionDaily = `-- name: CreateTaskCompletionDaily :exec
INSERT INTO task_completion_daily (task_id, target_date, completed_by_user_id, created_at)
VALUES ($1, $2, NULLIF($3, '')::uuid, NOW())
ON CONFLICT (task_id, target_date) DO NOTHING
`

type CreateTaskCompletionDailyParams struct {
	TaskID            string      `json:"task_id"`
	TargetDate        pgtype.Date `json:"target_date"`
	CompletedByUserID interface{} `json:"completed_by_user_id"`
}

func (q *Queries) CreateTaskCompletionDaily(ctx context.Context, arg CreateTaskCompletionDailyParams) error {
	_, err := q.db.Exec(ctx, createTaskCompletionDaily, arg.TaskID, arg.TargetDate, arg.CompletedByUserID)
	return err
}

const deleteLatestTaskCompletionWeeklyEntry = `-- name: DeleteLatestTaskCompletionWeeklyEntry :execrows
WITH latest AS (
  SELECT id
  FROM task_completion_weekly_entries e
  WHERE e.task_id = $1
    AND e.week_start = $2
  ORDER BY created_at DESC, id DESC
  LIMIT 1
)
DELETE FROM task_completion_weekly_entries e
USING latest
WHERE e.id = latest.id
`

type DeleteLatestTaskCompletionWeeklyEntryParams struct {
	TaskID    string      `json:"task_id"`
	WeekStart pgtype.Date `json:"week_start"`
}

func (q *Queries) DeleteLatestTaskCompletionWeeklyEntry(ctx context.Context, arg DeleteLatestTaskCompletionWeeklyEntryParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteLatestTaskCompletionWeeklyEntry, arg.TaskID, arg.WeekStart)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteTaskCompletionDaily = `-- name: DeleteTaskCompletionDaily :exec
DELETE FROM task_completion_daily
WHERE task_id = $1 AND target_date = $2
`

type DeleteTaskCompletionDailyParams struct {
	TaskID     string      `json:"task_id"`
	TargetDate pgtype.Date `json:"target_date"`
}

func (q *Queries) DeleteTaskCompletionDaily(ctx context.Context, arg DeleteTaskCompletionDailyParams) error {
	_, err := q.db.Exec(ctx, deleteTaskCompletionDaily, arg.TaskID, arg.TargetDate)
	return err
}

const deleteTaskCompletionDailyByTaskID = `-- name: DeleteTaskCompletionDailyByTaskID :exec
DELETE FROM task_completion_daily
WHERE task_id = $1
`

func (q *Queries) DeleteTaskCompletionDailyByTaskID(ctx context.Context, taskID string) error {
	_, err := q.db.Exec(ctx, deleteTaskCompletionDailyByTaskID, taskID)
	return err
}

const deleteTaskCompletionWeeklyEntriesByTaskID = `-- name: DeleteTaskCompletionWeeklyEntriesByTaskID :exec
DELETE FROM task_completion_weekly_entries
WHERE task_id = $1
`

func (q *Queries) DeleteTaskCompletionWeeklyEntriesByTaskID(ctx context.Context, taskID string) error {
	_, err := q.db.Exec(ctx, deleteTaskCompletionWeeklyEntriesByTaskID, taskID)
	return err
}

const getTaskCompletionWeeklyEntryCount = `-- name: GetTaskCompletionWeeklyEntryCount :one
SELECT COALESCE((
  SELECT COUNT(*)::integer
  FROM task_completion_weekly_entries
  WHERE task_id = $1 AND week_start = $2
), 0)::bigint
`

type GetTaskCompletionWeeklyEntryCountParams struct {
	TaskID    string      `json:"task_id"`
	WeekStart pgtype.Date `json:"week_start"`
}

func (q *Queries) GetTaskCompletionWeeklyEntryCount(ctx context.Context, arg GetTaskCompletionWeeklyEntryCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getTaskCompletionWeeklyEntryCount, arg.TaskID, arg.WeekStart)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const hasTaskCompletionDaily = `-- name: HasTaskCompletionDaily :one
SELECT EXISTS (
  SELECT 1
  FROM task_completion_daily
  WHERE task_id = $1 AND target_date = $2
)
`

type HasTaskCompletionDailyParams struct {
	TaskID     string      `json:"task_id"`
	TargetDate pgtype.Date `json:"target_date"`
}

func (q *Queries) HasTaskCompletionDaily(ctx context.Context, arg HasTaskCompletionDailyParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasTaskCompletionDaily, arg.TaskID, arg.TargetDate)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const insertTaskCompletionWeeklyEntry = `-- name: InsertTaskCompletionWeeklyEntry :exec
INSERT INTO task_completion_weekly_entries (id, task_id, week_start, completed_by_user_id, created_at)
VALUES ($1, $2, $3, NULLIF($4, '')::uuid, NOW())
`

type InsertTaskCompletionWeeklyEntryParams struct {
	ID                string      `json:"id"`
	TaskID            string      `json:"task_id"`
	WeekStart         pgtype.Date `json:"week_start"`
	CompletedByUserID interface{} `json:"completed_by_user_id"`
}

func (q *Queries) InsertTaskCompletionWeeklyEntry(ctx context.Context, arg InsertTaskCompletionWeeklyEntryParams) error {
	_, err := q.db.Exec(ctx, insertTaskCompletionWeeklyEntry,
		arg.ID,
		arg.TaskID,
		arg.WeekStart,
		arg.CompletedByUserID,
	)
	return err
}

const listTaskCompletionDailyByMonthAndTeam = `-- name: ListTaskCompletionDailyByMonthAndTeam :many
SELECT
  d.task_id,
  d.target_date,
  COALESCE(d.completed_by_user_id::text, ''::text) AS completed_by_user_id,
  COALESCE(NULLIF(u.nickname, ''), u.display_name, ''::text) AS completed_by_effective_name,
  u.color_hex AS completed_by_color_hex
FROM task_completion_daily d
JOIN tasks t ON t.id = d.task_id
LEFT JOIN users u ON u.id = d.completed_by_user_id
WHERE t.team_id = $1
  AND d.target_date >= $2
  AND d.target_date < $3
ORDER BY d.target_date, d.task_id
`

type ListTaskCompletionDailyByMonthAndTeamParams struct {
	TeamID       string      `json:"team_id"`
	TargetDate   pgtype.Date `json:"target_date"`
	TargetDate_2 pgtype.Date `json:"target_date_2"`
}

type ListTaskCompletionDailyByMonthAndTeamRow struct {
	TaskID                   string      `json:"task_id"`
	TargetDate               pgtype.Date `json:"target_date"`
	CompletedByUserID        interface{} `json:"completed_by_user_id"`
	CompletedByEffectiveName string      `json:"completed_by_effective_name"`
	CompletedByColorHex      pgtype.Text `json:"completed_by_color_hex"`
}

func (q *Queries) ListTaskCompletionDailyByMonthAndTeam(ctx context.Context, arg ListTaskCompletionDailyByMonthAndTeamParams) ([]ListTaskCompletionDailyByMonthAndTeamRow, error) {
	rows, err := q.db.Query(ctx, listTaskCompletionDailyByMonthAndTeam, arg.TeamID, arg.TargetDate, arg.TargetDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTaskCompletionDailyByMonthAndTeamRow
	for rows.Next() {
		var i ListTaskCompletionDailyByMonthAndTeamRow
		if err := rows.Scan(
			&i.TaskID,
			&i.TargetDate,
			&i.CompletedByUserID,
			&i.CompletedByEffectiveName,
			&i.CompletedByColorHex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTaskCompletionDailyByTeamAndDate = `-- name: ListTaskCompletionDailyByTeamAndDate :many
SELECT
  d.task_id,
  COALESCE(d.completed_by_user_id::text, ''::text) AS completed_by_user_id,
  COALESCE(NULLIF(u.nickname, ''), u.display_name, ''::text) AS completed_by_effective_name,
  u.color_hex AS completed_by_color_hex
FROM task_completion_daily d
JOIN tasks t ON t.id = d.task_id
LEFT JOIN users u ON u.id = d.completed_by_user_id
WHERE t.team_id = $1
  AND t.type = 'daily'
  AND d.target_date = $2
ORDER BY d.task_id
`

type ListTaskCompletionDailyByTeamAndDateParams struct {
	TeamID     string      `json:"team_id"`
	TargetDate pgtype.Date `json:"target_date"`
}

type ListTaskCompletionDailyByTeamAndDateRow struct {
	TaskID                   string      `json:"task_id"`
	CompletedByUserID        interface{} `json:"completed_by_user_id"`
	CompletedByEffectiveName string      `json:"completed_by_effective_name"`
	CompletedByColorHex      pgtype.Text `json:"completed_by_color_hex"`
}

func (q *Queries) ListTaskCompletionDailyByTeamAndDate(ctx context.Context, arg ListTaskCompletionDailyByTeamAndDateParams) ([]ListTaskCompletionDailyByTeamAndDateRow, error) {
	rows, err := q.db.Query(ctx, listTaskCompletionDailyByTeamAndDate, arg.TeamID, arg.TargetDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTaskCompletionDailyByTeamAndDateRow
	for rows.Next() {
		var i ListTaskCompletionDailyByTeamAndDateRow
		if err := rows.Scan(
			&i.TaskID,
			&i.CompletedByUserID,
			&i.CompletedByEffectiveName,
			&i.CompletedByColorHex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTaskCompletionWeeklyByMonthAndTeam = `-- name: ListTaskCompletionWeeklyByMonthAndTeam :many
SELECT e.task_id, e.week_start, COUNT(*)::integer AS completion_count
FROM task_completion_weekly_entries e
JOIN tasks t ON t.id = e.task_id
WHERE t.team_id = $1
  AND e.week_start >= $2
  AND e.week_start < $3
GROUP BY e.task_id, e.week_start
ORDER BY e.week_start, e.task_id
`

type ListTaskCompletionWeeklyByMonthAndTeamParams struct {
	TeamID      string      `json:"team_id"`
	WeekStart   pgtype.Date `json:"week_start"`
	WeekStart_2 pgtype.Date `json:"week_start_2"`
}

type ListTaskCompletionWeeklyByMonthAndTeamRow struct {
	TaskID          string      `json:"task_id"`
	WeekStart       pgtype.Date `json:"week_start"`
	CompletionCount int32       `json:"completion_count"`
}

func (q *Queries) ListTaskCompletionWeeklyByMonthAndTeam(ctx context.Context, arg ListTaskCompletionWeeklyByMonthAndTeamParams) ([]ListTaskCompletionWeeklyByMonthAndTeamRow, error) {
	rows, err := q.db.Query(ctx, listTaskCompletionWeeklyByMonthAndTeam, arg.TeamID, arg.WeekStart, arg.WeekStart_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTaskCompletionWeeklyByMonthAndTeamRow
	for rows.Next() {
		var i ListTaskCompletionWeeklyByMonthAndTeamRow
		if err := rows.Scan(&i.TaskID, &i.WeekStart, &i.CompletionCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTaskCompletionWeeklyCountsByTeamAndWeek = `-- name: ListTaskCompletionWeeklyCountsByTeamAndWeek :many
SELECT e.task_id, COUNT(*)::integer AS completion_count
FROM task_completion_weekly_entries e
JOIN tasks t ON t.id = e.task_id
WHERE t.team_id = $1
  AND t.type = 'weekly'
  AND e.week_start = $2
GROUP BY e.task_id
ORDER BY e.task_id
`

type ListTaskCompletionWeeklyCountsByTeamAndWeekParams struct {
	TeamID    string      `json:"team_id"`
	WeekStart pgtype.Date `json:"week_start"`
}

type ListTaskCompletionWeeklyCountsByTeamAndWeekRow struct {
	TaskID          string `json:"task_id"`
	CompletionCount int32  `json:"completion_count"`
}

func (q *Queries) ListTaskCompletionWeeklyCountsByTeamAndWeek(ctx context.Context, arg ListTaskCompletionWeeklyCountsByTeamAndWeekParams) ([]ListTaskCompletionWeeklyCountsByTeamAndWeekRow, error) {
	rows, err := q.db.Query(ctx, listTaskCompletionWeeklyCountsByTeamAndWeek, arg.TeamID, arg.WeekStart)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTaskCompletionWeeklyCountsByTeamAndWeekRow
	for rows.Next() {
		var i ListTaskCompletionWeeklyCountsByTeamAndWeekRow
		if err := rows.Scan(&i.TaskID, &i.CompletionCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTaskCompletionWeeklySlotsByMonthAndTeam = `-- name: ListTaskCompletionWeeklySlotsByMonthAndTeam :many
SELECT
  e.task_id,
  e.week_start,
  ROW_NUMBER() OVER (PARTITION BY e.task_id, e.week_start ORDER BY e.created_at ASC, e.id ASC)::integer AS slot,
  COALESCE(e.completed_by_user_id::text, ''::text) AS completed_by_user_id,
  COALESCE(NULLIF(u.nickname, ''), u.display_name, ''::text) AS completed_by_effective_name,
  u.color_hex AS completed_by_color_hex
FROM task_completion_weekly_entries e
JOIN tasks t ON t.id = e.task_id
LEFT JOIN users u ON u.id = e.completed_by_user_id
WHERE t.team_id = $1
  AND t.type = 'weekly'
  AND e.week_start >= $2
  AND e.week_start < $3
ORDER BY e.week_start, e.task_id, slot
`

type ListTaskCompletionWeeklySlotsByMonthAndTeamParams struct {
	TeamID      string      `json:"team_id"`
	WeekStart   pgtype.Date `json:"week_start"`
	WeekStart_2 pgtype.Date `json:"week_start_2"`
}

type ListTaskCompletionWeeklySlotsByMonthAndTeamRow struct {
	TaskID                   string      `json:"task_id"`
	WeekStart                pgtype.Date `json:"week_start"`
	Slot                     int32       `json:"slot"`
	CompletedByUserID        interface{} `json:"completed_by_user_id"`
	CompletedByEffectiveName string      `json:"completed_by_effective_name"`
	CompletedByColorHex      pgtype.Text `json:"completed_by_color_hex"`
}

func (q *Queries) ListTaskCompletionWeeklySlotsByMonthAndTeam(ctx context.Context, arg ListTaskCompletionWeeklySlotsByMonthAndTeamParams) ([]ListTaskCompletionWeeklySlotsByMonthAndTeamRow, error) {
	rows, err := q.db.Query(ctx, listTaskCompletionWeeklySlotsByMonthAndTeam, arg.TeamID, arg.WeekStart, arg.WeekStart_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTaskCompletionWeeklySlotsByMonthAndTeamRow
	for rows.Next() {
		var i ListTaskCompletionWeeklySlotsByMonthAndTeamRow
		if err := rows.Scan(
			&i.TaskID,
			&i.WeekStart,
			&i.Slot,
			&i.CompletedByUserID,
			&i.CompletedByEffectiveName,
			&i.CompletedByColorHex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTaskCompletionWeeklySlotsByTeamAndWeek = `-- name: ListTaskCompletionWeeklySlotsByTeamAndWeek :many
SELECT
  e.task_id,
  ROW_NUMBER() OVER (PARTITION BY e.task_id ORDER BY e.created_at ASC, e.id ASC)::integer AS slot,
  COALESCE(e.completed_by_user_id::text, ''::text) AS completed_by_user_id,
  COALESCE(NULLIF(u.nickname, ''), u.display_name, ''::text) AS completed_by_effective_name,
  u.color_hex AS completed_by_color_hex
FROM task_completion_weekly_entries e
JOIN tasks t ON t.id = e.task_id
LEFT JOIN users u ON u.id = e.completed_by_user_id
WHERE t.team_id = $1
  AND t.type = 'weekly'
  AND e.week_start = $2
ORDER BY e.task_id, slot
`

type ListTaskCompletionWeeklySlotsByTeamAndWeekParams struct {
	TeamID    string      `json:"team_id"`
	WeekStart pgtype.Date `json:"week_start"`
}

type ListTaskCompletionWeeklySlotsByTeamAndWeekRow struct {
	TaskID                   string      `json:"task_id"`
	Slot                     int32       `json:"slot"`
	CompletedByUserID        interface{} `json:"completed_by_user_id"`
	CompletedByEffectiveName string      `json:"completed_by_effective_name"`
	CompletedByColorHex      pgtype.Text `json:"completed_by_color_hex"`
}

func (q *Queries) ListTaskCompletionWeeklySlotsByTeamAndWeek(ctx context.Context, arg ListTaskCompletionWeeklySlotsByTeamAndWeekParams) ([]ListTaskCompletionWeeklySlotsByTeamAndWeekRow, error) {
	rows, err := q.db.Query(ctx, listTaskCompletionWeeklySlotsByTeamAndWeek, arg.TeamID, arg.WeekStart)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTaskCompletionWeeklySlotsByTeamAndWeekRow
	for rows.Next() {
		var i ListTaskCompletionWeeklySlotsByTeamAndWeekRow
		if err := rows.Scan(
			&i.TaskID,
			&i.Slot,
			&i.CompletedByUserID,
			&i.CompletedByEffectiveName,
			&i.CompletedByColorHex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
