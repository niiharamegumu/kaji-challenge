// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: task_completions.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTaskCompletionDaily = `-- name: CreateTaskCompletionDaily :exec
INSERT INTO task_completion_daily (task_id, target_date, created_at)
VALUES ($1, $2, NOW())
ON CONFLICT (task_id, target_date) DO NOTHING
`

type CreateTaskCompletionDailyParams struct {
	TaskID     string      `json:"task_id"`
	TargetDate pgtype.Date `json:"target_date"`
}

func (q *Queries) CreateTaskCompletionDaily(ctx context.Context, arg CreateTaskCompletionDailyParams) error {
	_, err := q.db.Exec(ctx, createTaskCompletionDaily, arg.TaskID, arg.TargetDate)
	return err
}

const decrementTaskCompletionWeekly = `-- name: DecrementTaskCompletionWeekly :one
INSERT INTO task_completion_weekly (task_id, week_start, completion_count, created_at, updated_at)
VALUES ($1, $2, 0, NOW(), NOW())
ON CONFLICT (task_id, week_start) DO UPDATE
SET completion_count = GREATEST(0, task_completion_weekly.completion_count - 1),
    updated_at = NOW()
RETURNING completion_count::bigint
`

type DecrementTaskCompletionWeeklyParams struct {
	TaskID    string      `json:"task_id"`
	WeekStart pgtype.Date `json:"week_start"`
}

func (q *Queries) DecrementTaskCompletionWeekly(ctx context.Context, arg DecrementTaskCompletionWeeklyParams) (int64, error) {
	row := q.db.QueryRow(ctx, decrementTaskCompletionWeekly, arg.TaskID, arg.WeekStart)
	var completion_count int64
	err := row.Scan(&completion_count)
	return completion_count, err
}

const deleteTaskCompletionDaily = `-- name: DeleteTaskCompletionDaily :exec
DELETE FROM task_completion_daily
WHERE task_id = $1 AND target_date = $2
`

type DeleteTaskCompletionDailyParams struct {
	TaskID     string      `json:"task_id"`
	TargetDate pgtype.Date `json:"target_date"`
}

func (q *Queries) DeleteTaskCompletionDaily(ctx context.Context, arg DeleteTaskCompletionDailyParams) error {
	_, err := q.db.Exec(ctx, deleteTaskCompletionDaily, arg.TaskID, arg.TargetDate)
	return err
}

const deleteTaskCompletionDailyByTaskID = `-- name: DeleteTaskCompletionDailyByTaskID :exec
DELETE FROM task_completion_daily
WHERE task_id = $1
`

func (q *Queries) DeleteTaskCompletionDailyByTaskID(ctx context.Context, taskID string) error {
	_, err := q.db.Exec(ctx, deleteTaskCompletionDailyByTaskID, taskID)
	return err
}

const deleteTaskCompletionWeekly = `-- name: DeleteTaskCompletionWeekly :exec
DELETE FROM task_completion_weekly
WHERE task_id = $1 AND week_start = $2
`

type DeleteTaskCompletionWeeklyParams struct {
	TaskID    string      `json:"task_id"`
	WeekStart pgtype.Date `json:"week_start"`
}

func (q *Queries) DeleteTaskCompletionWeekly(ctx context.Context, arg DeleteTaskCompletionWeeklyParams) error {
	_, err := q.db.Exec(ctx, deleteTaskCompletionWeekly, arg.TaskID, arg.WeekStart)
	return err
}

const deleteTaskCompletionWeeklyByTaskID = `-- name: DeleteTaskCompletionWeeklyByTaskID :exec
DELETE FROM task_completion_weekly
WHERE task_id = $1
`

func (q *Queries) DeleteTaskCompletionWeeklyByTaskID(ctx context.Context, taskID string) error {
	_, err := q.db.Exec(ctx, deleteTaskCompletionWeeklyByTaskID, taskID)
	return err
}

const deleteTaskCompletionWeeklyIfZero = `-- name: DeleteTaskCompletionWeeklyIfZero :exec
DELETE FROM task_completion_weekly
WHERE task_id = $1 AND week_start = $2 AND completion_count = 0
`

type DeleteTaskCompletionWeeklyIfZeroParams struct {
	TaskID    string      `json:"task_id"`
	WeekStart pgtype.Date `json:"week_start"`
}

func (q *Queries) DeleteTaskCompletionWeeklyIfZero(ctx context.Context, arg DeleteTaskCompletionWeeklyIfZeroParams) error {
	_, err := q.db.Exec(ctx, deleteTaskCompletionWeeklyIfZero, arg.TaskID, arg.WeekStart)
	return err
}

const getTaskCompletionWeeklyCount = `-- name: GetTaskCompletionWeeklyCount :one
SELECT COALESCE((
  SELECT completion_count
  FROM task_completion_weekly
  WHERE task_id = $1 AND week_start = $2
), 0)::bigint
`

type GetTaskCompletionWeeklyCountParams struct {
	TaskID    string      `json:"task_id"`
	WeekStart pgtype.Date `json:"week_start"`
}

func (q *Queries) GetTaskCompletionWeeklyCount(ctx context.Context, arg GetTaskCompletionWeeklyCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getTaskCompletionWeeklyCount, arg.TaskID, arg.WeekStart)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const hasTaskCompletionDaily = `-- name: HasTaskCompletionDaily :one
SELECT EXISTS (
  SELECT 1
  FROM task_completion_daily
  WHERE task_id = $1 AND target_date = $2
)
`

type HasTaskCompletionDailyParams struct {
	TaskID     string      `json:"task_id"`
	TargetDate pgtype.Date `json:"target_date"`
}

func (q *Queries) HasTaskCompletionDaily(ctx context.Context, arg HasTaskCompletionDailyParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasTaskCompletionDaily, arg.TaskID, arg.TargetDate)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const incrementTaskCompletionWeekly = `-- name: IncrementTaskCompletionWeekly :one
INSERT INTO task_completion_weekly (task_id, week_start, completion_count, created_at, updated_at)
VALUES ($1, $2, 1, NOW(), NOW())
ON CONFLICT (task_id, week_start) DO UPDATE
SET completion_count = LEAST($3::integer, task_completion_weekly.completion_count + 1),
    updated_at = NOW()
RETURNING completion_count::bigint
`

type IncrementTaskCompletionWeeklyParams struct {
	TaskID        string      `json:"task_id"`
	WeekStart     pgtype.Date `json:"week_start"`
	MaxCompletion int32       `json:"max_completion"`
}

func (q *Queries) IncrementTaskCompletionWeekly(ctx context.Context, arg IncrementTaskCompletionWeeklyParams) (int64, error) {
	row := q.db.QueryRow(ctx, incrementTaskCompletionWeekly, arg.TaskID, arg.WeekStart, arg.MaxCompletion)
	var completion_count int64
	err := row.Scan(&completion_count)
	return completion_count, err
}

const listCompletedDailyTaskIDsByTeamAndDate = `-- name: ListCompletedDailyTaskIDsByTeamAndDate :many
SELECT d.task_id
FROM task_completion_daily d
JOIN tasks t ON t.id = d.task_id
WHERE t.team_id = $1
  AND t.type = 'daily'
  AND d.target_date = $2
ORDER BY d.task_id
`

type ListCompletedDailyTaskIDsByTeamAndDateParams struct {
	TeamID     string      `json:"team_id"`
	TargetDate pgtype.Date `json:"target_date"`
}

func (q *Queries) ListCompletedDailyTaskIDsByTeamAndDate(ctx context.Context, arg ListCompletedDailyTaskIDsByTeamAndDateParams) ([]string, error) {
	rows, err := q.db.Query(ctx, listCompletedDailyTaskIDsByTeamAndDate, arg.TeamID, arg.TargetDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var task_id string
		if err := rows.Scan(&task_id); err != nil {
			return nil, err
		}
		items = append(items, task_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTaskCompletionDailyByMonthAndTeam = `-- name: ListTaskCompletionDailyByMonthAndTeam :many
SELECT d.task_id, d.target_date
FROM task_completion_daily d
JOIN tasks t ON t.id = d.task_id
WHERE t.team_id = $1
  AND d.target_date >= $2
  AND d.target_date < $3
ORDER BY d.target_date, d.task_id
`

type ListTaskCompletionDailyByMonthAndTeamParams struct {
	TeamID       string      `json:"team_id"`
	TargetDate   pgtype.Date `json:"target_date"`
	TargetDate_2 pgtype.Date `json:"target_date_2"`
}

type ListTaskCompletionDailyByMonthAndTeamRow struct {
	TaskID     string      `json:"task_id"`
	TargetDate pgtype.Date `json:"target_date"`
}

func (q *Queries) ListTaskCompletionDailyByMonthAndTeam(ctx context.Context, arg ListTaskCompletionDailyByMonthAndTeamParams) ([]ListTaskCompletionDailyByMonthAndTeamRow, error) {
	rows, err := q.db.Query(ctx, listTaskCompletionDailyByMonthAndTeam, arg.TeamID, arg.TargetDate, arg.TargetDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTaskCompletionDailyByMonthAndTeamRow
	for rows.Next() {
		var i ListTaskCompletionDailyByMonthAndTeamRow
		if err := rows.Scan(&i.TaskID, &i.TargetDate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTaskCompletionWeeklyByMonthAndTeam = `-- name: ListTaskCompletionWeeklyByMonthAndTeam :many
SELECT w.task_id, w.week_start, w.completion_count
FROM task_completion_weekly w
JOIN tasks t ON t.id = w.task_id
WHERE t.team_id = $1
  AND w.week_start >= $2
  AND w.week_start < $3
ORDER BY w.week_start, w.task_id
`

type ListTaskCompletionWeeklyByMonthAndTeamParams struct {
	TeamID      string      `json:"team_id"`
	WeekStart   pgtype.Date `json:"week_start"`
	WeekStart_2 pgtype.Date `json:"week_start_2"`
}

type ListTaskCompletionWeeklyByMonthAndTeamRow struct {
	TaskID          string      `json:"task_id"`
	WeekStart       pgtype.Date `json:"week_start"`
	CompletionCount int32       `json:"completion_count"`
}

func (q *Queries) ListTaskCompletionWeeklyByMonthAndTeam(ctx context.Context, arg ListTaskCompletionWeeklyByMonthAndTeamParams) ([]ListTaskCompletionWeeklyByMonthAndTeamRow, error) {
	rows, err := q.db.Query(ctx, listTaskCompletionWeeklyByMonthAndTeam, arg.TeamID, arg.WeekStart, arg.WeekStart_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTaskCompletionWeeklyByMonthAndTeamRow
	for rows.Next() {
		var i ListTaskCompletionWeeklyByMonthAndTeamRow
		if err := rows.Scan(&i.TaskID, &i.WeekStart, &i.CompletionCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTaskCompletionWeeklyCountsByTeamAndWeek = `-- name: ListTaskCompletionWeeklyCountsByTeamAndWeek :many
SELECT w.task_id, w.completion_count
FROM task_completion_weekly w
JOIN tasks t ON t.id = w.task_id
WHERE t.team_id = $1
  AND t.type = 'weekly'
  AND w.week_start = $2
ORDER BY w.task_id
`

type ListTaskCompletionWeeklyCountsByTeamAndWeekParams struct {
	TeamID    string      `json:"team_id"`
	WeekStart pgtype.Date `json:"week_start"`
}

type ListTaskCompletionWeeklyCountsByTeamAndWeekRow struct {
	TaskID          string `json:"task_id"`
	CompletionCount int32  `json:"completion_count"`
}

func (q *Queries) ListTaskCompletionWeeklyCountsByTeamAndWeek(ctx context.Context, arg ListTaskCompletionWeeklyCountsByTeamAndWeekParams) ([]ListTaskCompletionWeeklyCountsByTeamAndWeekRow, error) {
	rows, err := q.db.Query(ctx, listTaskCompletionWeeklyCountsByTeamAndWeek, arg.TeamID, arg.WeekStart)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTaskCompletionWeeklyCountsByTeamAndWeekRow
	for rows.Next() {
		var i ListTaskCompletionWeeklyCountsByTeamAndWeekRow
		if err := rows.Scan(&i.TaskID, &i.CompletionCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toggleTaskCompletionWeeklyBinary = `-- name: ToggleTaskCompletionWeeklyBinary :one
INSERT INTO task_completion_weekly (task_id, week_start, completion_count, created_at, updated_at)
VALUES ($1, $2, 1, NOW(), NOW())
ON CONFLICT (task_id, week_start) DO UPDATE
SET completion_count = CASE
  WHEN task_completion_weekly.completion_count > 0 THEN 0
  ELSE 1
END,
    updated_at = NOW()
RETURNING completion_count::bigint
`

type ToggleTaskCompletionWeeklyBinaryParams struct {
	TaskID    string      `json:"task_id"`
	WeekStart pgtype.Date `json:"week_start"`
}

func (q *Queries) ToggleTaskCompletionWeeklyBinary(ctx context.Context, arg ToggleTaskCompletionWeeklyBinaryParams) (int64, error) {
	row := q.db.QueryRow(ctx, toggleTaskCompletionWeeklyBinary, arg.TaskID, arg.WeekStart)
	var completion_count int64
	err := row.Scan(&completion_count)
	return completion_count, err
}

const upsertTaskCompletionWeeklyCount = `-- name: UpsertTaskCompletionWeeklyCount :exec
INSERT INTO task_completion_weekly (task_id, week_start, completion_count, created_at, updated_at)
VALUES ($1, $2, $3, NOW(), NOW())
ON CONFLICT (task_id, week_start) DO UPDATE
SET completion_count = EXCLUDED.completion_count,
    updated_at = NOW()
`

type UpsertTaskCompletionWeeklyCountParams struct {
	TaskID          string      `json:"task_id"`
	WeekStart       pgtype.Date `json:"week_start"`
	CompletionCount int32       `json:"completion_count"`
}

func (q *Queries) UpsertTaskCompletionWeeklyCount(ctx context.Context, arg UpsertTaskCompletionWeeklyCountParams) error {
	_, err := q.db.Exec(ctx, upsertTaskCompletionWeeklyCount, arg.TaskID, arg.WeekStart, arg.CompletionCount)
	return err
}
